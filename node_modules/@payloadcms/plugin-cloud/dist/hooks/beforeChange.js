"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "getBeforeChangeHook", {
    enumerable: true,
    get: function() {
        return getBeforeChangeHook;
    }
});
const _libstorage = require("@aws-sdk/lib-storage");
const _fs = /*#__PURE__*/ _interop_require_default(require("fs"));
const _createKey = require("../utilities/createKey");
const _getIncomingFiles = require("../utilities/getIncomingFiles");
const _getStorageClient = require("../utilities/getStorageClient");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const MB = 1024 * 1024;
const getBeforeChangeHook = ({ collection })=>async ({ data, req })=>{
        try {
            const files = (0, _getIncomingFiles.getIncomingFiles)({
                data,
                req
            });
            req.payload.logger.debug({
                msg: `Preparing to upload ${files.length} files`
            });
            const { identityID, storageClient } = await (0, _getStorageClient.getStorageClient)();
            const promises = files.map(async (file)=>{
                const fileKey = file.filename;
                req.payload.logger.debug({
                    fileKey,
                    msg: `File buffer length: ${file.buffer.length / MB}MB`,
                    tempFilePath: file.tempFilePath ?? 'undefined'
                });
                const fileBufferOrStream = file.tempFilePath ? _fs.default.createReadStream(file.tempFilePath) : file.buffer;
                if (file.buffer.length > 0) {
                    req.payload.logger.debug({
                        fileKey,
                        msg: `Uploading ${fileKey} from buffer. Size: ${file.buffer.length / MB}MB`
                    });
                    await storageClient.putObject({
                        Body: fileBufferOrStream,
                        Bucket: process.env.PAYLOAD_CLOUD_BUCKET,
                        ContentType: file.mimeType,
                        Key: (0, _createKey.createKey)({
                            collection: collection.slug,
                            filename: fileKey,
                            identityID
                        })
                    });
                }
                // This will buffer at max 4 * 5MB = 20MB. Default queueSize is 4 and default partSize is 5MB.
                const parallelUploadS3 = new _libstorage.Upload({
                    client: storageClient,
                    params: {
                        Body: fileBufferOrStream,
                        Bucket: process.env.PAYLOAD_CLOUD_BUCKET,
                        ContentType: file.mimeType,
                        Key: (0, _createKey.createKey)({
                            collection: collection.slug,
                            filename: fileKey,
                            identityID
                        })
                    }
                });
                parallelUploadS3.on('httpUploadProgress', (progress)=>{
                    if (progress.total) {
                        req.payload.logger.debug({
                            fileKey,
                            msg: `Uploaded part ${progress.part} - ${(progress.loaded || 0) / MB}MB out of ${(progress.total || 0) / MB}MB`
                        });
                    }
                });
                await parallelUploadS3.done();
            });
            await Promise.all(promises);
        } catch (err) {
            req.payload.logger.error(`There was an error while uploading files corresponding to the collection ${collection.slug} with filename ${data.filename}:`);
            req.payload.logger.error(err);
        }
        return data;
    };

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9ob29rcy9iZWZvcmVDaGFuZ2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBUeXBlV2l0aElELCBGaWxlRGF0YSB9IGZyb20gJ3BheWxvYWQvdHlwZXMnXG5pbXBvcnQgdHlwZSB7IENvbGxlY3Rpb25CZWZvcmVDaGFuZ2VIb29rLCBDb2xsZWN0aW9uQ29uZmlnIH0gZnJvbSAncGF5bG9hZC90eXBlcydcbmltcG9ydCB0eXBlIHN0cmVhbSBmcm9tICdzdHJlYW0nXG5cbmltcG9ydCB7IFVwbG9hZCB9IGZyb20gJ0Bhd3Mtc2RrL2xpYi1zdG9yYWdlJ1xuaW1wb3J0IGZzIGZyb20gJ2ZzJ1xuXG5pbXBvcnQgeyBjcmVhdGVLZXkgfSBmcm9tICcuLi91dGlsaXRpZXMvY3JlYXRlS2V5J1xuaW1wb3J0IHsgZ2V0SW5jb21pbmdGaWxlcyB9IGZyb20gJy4uL3V0aWxpdGllcy9nZXRJbmNvbWluZ0ZpbGVzJ1xuaW1wb3J0IHsgZ2V0U3RvcmFnZUNsaWVudCB9IGZyb20gJy4uL3V0aWxpdGllcy9nZXRTdG9yYWdlQ2xpZW50J1xuXG5pbnRlcmZhY2UgQXJncyB7XG4gIGNvbGxlY3Rpb246IENvbGxlY3Rpb25Db25maWdcbn1cblxuY29uc3QgTUIgPSAxMDI0ICogMTAyNFxuXG5leHBvcnQgY29uc3QgZ2V0QmVmb3JlQ2hhbmdlSG9vayA9XG4gICh7IGNvbGxlY3Rpb24gfTogQXJncyk6IENvbGxlY3Rpb25CZWZvcmVDaGFuZ2VIb29rPEZpbGVEYXRhICYgVHlwZVdpdGhJRD4gPT5cbiAgYXN5bmMgKHsgZGF0YSwgcmVxIH0pID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZmlsZXMgPSBnZXRJbmNvbWluZ0ZpbGVzKHsgZGF0YSwgcmVxIH0pXG5cbiAgICAgIHJlcS5wYXlsb2FkLmxvZ2dlci5kZWJ1Zyh7XG4gICAgICAgIG1zZzogYFByZXBhcmluZyB0byB1cGxvYWQgJHtmaWxlcy5sZW5ndGh9IGZpbGVzYCxcbiAgICAgIH0pXG5cbiAgICAgIGNvbnN0IHsgaWRlbnRpdHlJRCwgc3RvcmFnZUNsaWVudCB9ID0gYXdhaXQgZ2V0U3RvcmFnZUNsaWVudCgpXG5cbiAgICAgIGNvbnN0IHByb21pc2VzID0gZmlsZXMubWFwKGFzeW5jIChmaWxlKSA9PiB7XG4gICAgICAgIGNvbnN0IGZpbGVLZXkgPSBmaWxlLmZpbGVuYW1lXG5cbiAgICAgICAgcmVxLnBheWxvYWQubG9nZ2VyLmRlYnVnKHtcbiAgICAgICAgICBmaWxlS2V5LFxuICAgICAgICAgIG1zZzogYEZpbGUgYnVmZmVyIGxlbmd0aDogJHtmaWxlLmJ1ZmZlci5sZW5ndGggLyBNQn1NQmAsXG4gICAgICAgICAgdGVtcEZpbGVQYXRoOiBmaWxlLnRlbXBGaWxlUGF0aCA/PyAndW5kZWZpbmVkJyxcbiAgICAgICAgfSlcblxuICAgICAgICBjb25zdCBmaWxlQnVmZmVyT3JTdHJlYW06IEJ1ZmZlciB8IHN0cmVhbS5SZWFkYWJsZSA9IGZpbGUudGVtcEZpbGVQYXRoXG4gICAgICAgICAgPyBmcy5jcmVhdGVSZWFkU3RyZWFtKGZpbGUudGVtcEZpbGVQYXRoKVxuICAgICAgICAgIDogZmlsZS5idWZmZXJcblxuICAgICAgICBpZiAoZmlsZS5idWZmZXIubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHJlcS5wYXlsb2FkLmxvZ2dlci5kZWJ1Zyh7XG4gICAgICAgICAgICBmaWxlS2V5LFxuICAgICAgICAgICAgbXNnOiBgVXBsb2FkaW5nICR7ZmlsZUtleX0gZnJvbSBidWZmZXIuIFNpemU6ICR7ZmlsZS5idWZmZXIubGVuZ3RoIC8gTUJ9TUJgLFxuICAgICAgICAgIH0pXG5cbiAgICAgICAgICBhd2FpdCBzdG9yYWdlQ2xpZW50LnB1dE9iamVjdCh7XG4gICAgICAgICAgICBCb2R5OiBmaWxlQnVmZmVyT3JTdHJlYW0sXG4gICAgICAgICAgICBCdWNrZXQ6IHByb2Nlc3MuZW52LlBBWUxPQURfQ0xPVURfQlVDS0VULFxuICAgICAgICAgICAgQ29udGVudFR5cGU6IGZpbGUubWltZVR5cGUsXG4gICAgICAgICAgICBLZXk6IGNyZWF0ZUtleSh7IGNvbGxlY3Rpb246IGNvbGxlY3Rpb24uc2x1ZywgZmlsZW5hbWU6IGZpbGVLZXksIGlkZW50aXR5SUQgfSksXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoaXMgd2lsbCBidWZmZXIgYXQgbWF4IDQgKiA1TUIgPSAyME1CLiBEZWZhdWx0IHF1ZXVlU2l6ZSBpcyA0IGFuZCBkZWZhdWx0IHBhcnRTaXplIGlzIDVNQi5cbiAgICAgICAgY29uc3QgcGFyYWxsZWxVcGxvYWRTMyA9IG5ldyBVcGxvYWQoe1xuICAgICAgICAgIGNsaWVudDogc3RvcmFnZUNsaWVudCxcbiAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgIEJvZHk6IGZpbGVCdWZmZXJPclN0cmVhbSxcbiAgICAgICAgICAgIEJ1Y2tldDogcHJvY2Vzcy5lbnYuUEFZTE9BRF9DTE9VRF9CVUNLRVQsXG4gICAgICAgICAgICBDb250ZW50VHlwZTogZmlsZS5taW1lVHlwZSxcbiAgICAgICAgICAgIEtleTogY3JlYXRlS2V5KHsgY29sbGVjdGlvbjogY29sbGVjdGlvbi5zbHVnLCBmaWxlbmFtZTogZmlsZUtleSwgaWRlbnRpdHlJRCB9KSxcbiAgICAgICAgICB9LFxuICAgICAgICB9KVxuXG4gICAgICAgIHBhcmFsbGVsVXBsb2FkUzMub24oJ2h0dHBVcGxvYWRQcm9ncmVzcycsIChwcm9ncmVzcykgPT4ge1xuICAgICAgICAgIGlmIChwcm9ncmVzcy50b3RhbCkge1xuICAgICAgICAgICAgcmVxLnBheWxvYWQubG9nZ2VyLmRlYnVnKHtcbiAgICAgICAgICAgICAgZmlsZUtleSxcbiAgICAgICAgICAgICAgbXNnOiBgVXBsb2FkZWQgcGFydCAke3Byb2dyZXNzLnBhcnR9IC0gJHsocHJvZ3Jlc3MubG9hZGVkIHx8IDApIC8gTUJ9TUIgb3V0IG9mICR7XG4gICAgICAgICAgICAgICAgKHByb2dyZXNzLnRvdGFsIHx8IDApIC8gTUJcbiAgICAgICAgICAgICAgfU1CYCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuXG4gICAgICAgIGF3YWl0IHBhcmFsbGVsVXBsb2FkUzMuZG9uZSgpXG4gICAgICB9KVxuXG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcylcbiAgICB9IGNhdGNoIChlcnI6IHVua25vd24pIHtcbiAgICAgIHJlcS5wYXlsb2FkLmxvZ2dlci5lcnJvcihcbiAgICAgICAgYFRoZXJlIHdhcyBhbiBlcnJvciB3aGlsZSB1cGxvYWRpbmcgZmlsZXMgY29ycmVzcG9uZGluZyB0byB0aGUgY29sbGVjdGlvbiAke2NvbGxlY3Rpb24uc2x1Z30gd2l0aCBmaWxlbmFtZSAke2RhdGEuZmlsZW5hbWV9OmAsXG4gICAgICApXG4gICAgICByZXEucGF5bG9hZC5sb2dnZXIuZXJyb3IoZXJyKVxuICAgIH1cbiAgICByZXR1cm4gZGF0YVxuICB9XG4iXSwibmFtZXMiOlsiZ2V0QmVmb3JlQ2hhbmdlSG9vayIsIk1CIiwiY29sbGVjdGlvbiIsImRhdGEiLCJyZXEiLCJmaWxlcyIsImdldEluY29taW5nRmlsZXMiLCJwYXlsb2FkIiwibG9nZ2VyIiwiZGVidWciLCJtc2ciLCJsZW5ndGgiLCJpZGVudGl0eUlEIiwic3RvcmFnZUNsaWVudCIsImdldFN0b3JhZ2VDbGllbnQiLCJwcm9taXNlcyIsIm1hcCIsImZpbGUiLCJmaWxlS2V5IiwiZmlsZW5hbWUiLCJidWZmZXIiLCJ0ZW1wRmlsZVBhdGgiLCJmaWxlQnVmZmVyT3JTdHJlYW0iLCJmcyIsImNyZWF0ZVJlYWRTdHJlYW0iLCJwdXRPYmplY3QiLCJCb2R5IiwiQnVja2V0IiwicHJvY2VzcyIsImVudiIsIlBBWUxPQURfQ0xPVURfQlVDS0VUIiwiQ29udGVudFR5cGUiLCJtaW1lVHlwZSIsIktleSIsImNyZWF0ZUtleSIsInNsdWciLCJwYXJhbGxlbFVwbG9hZFMzIiwiVXBsb2FkIiwiY2xpZW50IiwicGFyYW1zIiwib24iLCJwcm9ncmVzcyIs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