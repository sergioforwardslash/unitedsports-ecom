"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "payloadCloudEmail", {
    enumerable: true,
    get: function() {
        return payloadCloudEmail;
    }
});
const _nodemailer = /*#__PURE__*/ _interop_require_default(require("nodemailer"));
const _resend = require("resend");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const payloadCloudEmail = (args)=>{
    if (process.env.PAYLOAD_CLOUD !== 'true' || !args) {
        return undefined;
    }
    if (!args.apiKey) throw new Error('apiKey must be provided to use Payload Cloud Email ');
    if (!args.defaultDomain) throw new Error('defaultDomain must be provided to use Payload Cloud Email');
    const { apiKey, config, defaultDomain } = args;
    const customDomainEnvs = Object.keys(process.env).filter((e)=>e.startsWith('PAYLOAD_CLOUD_EMAIL_DOMAIN_') && !e.endsWith('API_KEY'));
    // Match up the envs with api keys: { key: PAYLOAD_CLOUD_EMAIL_DOMAIN_${i}, value: domain }
    const customDomainsResendMap = customDomainEnvs?.reduce((acc, envKey)=>{
        const apiKey = process.env[`${envKey}_API_KEY`];
        if (!apiKey) {
            throw new Error(`PAYLOAD_CLOUD_EMAIL_DOMAIN_${envKey} is missing a corresponding PAYLOAD_CLOUD_EMAIL_DOMAIN_${envKey}_API_KEY`);
        }
        acc[process.env[envKey]] = new _resend.Resend(apiKey);
        return acc;
    }, {}) || {};
    const customDomains = Object.keys(customDomainsResendMap);
    if (customDomains.length) {
        console.log(`Configuring Payload Cloud Email for ${[
            defaultDomain,
            ...customDomains || []
        ].join(', ')}`);
    }
    const resendDomainMap = {
        [defaultDomain]: new _resend.Resend(apiKey),
        ...customDomainsResendMap
    };
    const fromName = config.email?.fromName || 'Payload CMS';
    const fromAddress = config.email?.fromAddress || `cms@${customDomains.length ? customDomains[0] : defaultDomain}`;
    const existingTransport = config.email && 'transport' in config.email && config.email?.transport;
    if (existingTransport) {
        return {
            fromAddress: fromAddress,
            fromName: fromName,
            transport: existingTransport
        };
    }
    const transportConfig = {
        name: 'payload-cloud',
        send: async (mail, callback)=>{
            const { from, html, subject, text, to } = mail.data;
            if (!to) return callback(new Error('No "to" address provided'), null);
            if (!from) return callback(new Error('No "from" address provided'), null);
            const cleanTo = [];
            const toArr = Array.isArray(to) ? to : [
                to
            ];
            toArr.forEach((toItem)=>{
                if (typeof toItem === 'string') {
                    cleanTo.push(toItem);
                } else {
                    cleanTo.push(toItem.address);
                }
            });
            let fromToUse;
            if (typeof from === 'string') {
                fromToUse = from;
            } else if (typeof from === 'object' && 'name' in from && 'address' in from) {
                fromToUse = `${from.name} <${from.address}>`;
            } else {
                fromToUse = `${fromName} <${fromAddress}>`;
            }
            // Parse domain. Can be in 2 possible formats:  "name@domain.com" or "Friendly Name <name@domain.com>"
            const domainMatch = fromToUse.match(/(?<=@)[^(\s|>)]+/g);
            if (!domainMatch) {
                return callback(new Error(`Could not parse domain from "from" address: ${fromToUse}`), null);
            }
            const fromDomain = domainMatch[0];
            const resend = resendDomainMap[fromDomain];
            if (!resend) {
                callback(new Error(`No Resend instance found for domain: ${fromDomain}. Available domains: ${Object.keys(resendDomainMap).join(', ')}`), null);
            }
            try {
                const sendResponse = await resend.sendEmail({
                    from: fromToUse,
                    html: html || text,
                    subject: subject || '<No subject>',
                    to: cleanTo
                });
                if ('error' in sendResponse) {
                    return callback(new Error('Error sending email', {
                        cause: sendResponse.error
                    }), null);
                }
                return callback(null, sendResponse);
            } catch (err) {
                if (isResendError(err)) {
                    return callback(new Error(`Error sending email: ${err.statusCode} ${err.name}: ${err.message}`), null);
                } else if (err instanceof Error) {
                    return callback(new Error(`Unexpected error sending email: ${err.message}: ${err.stack}`), null);
                } else {
                    return callback(new Error(`Unexpected error sending email: ${err}`), null);
                }
            }
        },
        version: '0.0.1'
    };
    return {
        fromAddress: fromAddress,
        fromName: fromName,
        transport: _nodemailer.default.createTransport(transportConfig)
    };
};
function isResendError(err) {
    return Boolean(err && typeof err === 'object' && 'message' in err && 'statusCode' in err && 'name' in err);
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9lbWFpbC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IEVtYWlsVHJhbnNwb3J0IH0gZnJvbSAncGF5bG9hZC9jb25maWcnXG5cbmltcG9ydCBub2RlbWFpbGVyIGZyb20gJ25vZGVtYWlsZXInXG5pbXBvcnQgeyBSZXNlbmQgfSBmcm9tICdyZXNlbmQnXG5cbmltcG9ydCB0eXBlIHsgUGF5bG9hZENsb3VkRW1haWxPcHRpb25zIH0gZnJvbSAnLi90eXBlcydcblxudHlwZSBUcmFuc3BvcnRBcmdzID0gUGFyYW1ldGVyczx0eXBlb2Ygbm9kZW1haWxlci5jcmVhdGVUcmFuc3BvcnQ+WzBdXG5cbmV4cG9ydCBjb25zdCBwYXlsb2FkQ2xvdWRFbWFpbCA9IChhcmdzOiBQYXlsb2FkQ2xvdWRFbWFpbE9wdGlvbnMpOiBFbWFpbFRyYW5zcG9ydCB8IHVuZGVmaW5lZCA9PiB7XG4gIGlmIChwcm9jZXNzLmVudi5QQVlMT0FEX0NMT1VEICE9PSAndHJ1ZScgfHwgIWFyZ3MpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cblxuICBpZiAoIWFyZ3MuYXBpS2V5KSB0aHJvdyBuZXcgRXJyb3IoJ2FwaUtleSBtdXN0IGJlIHByb3ZpZGVkIHRvIHVzZSBQYXlsb2FkIENsb3VkIEVtYWlsICcpXG4gIGlmICghYXJncy5kZWZhdWx0RG9tYWluKVxuICAgIHRocm93IG5ldyBFcnJvcignZGVmYXVsdERvbWFpbiBtdXN0IGJlIHByb3ZpZGVkIHRvIHVzZSBQYXlsb2FkIENsb3VkIEVtYWlsJylcblxuICBjb25zdCB7IGFwaUtleSwgY29uZmlnLCBkZWZhdWx0RG9tYWluIH0gPSBhcmdzXG5cbiAgY29uc3QgY3VzdG9tRG9tYWluRW52cyA9IE9iamVjdC5rZXlzKHByb2Nlc3MuZW52KS5maWx0ZXIoXG4gICAgKGUpID0+IGUuc3RhcnRzV2l0aCgnUEFZTE9BRF9DTE9VRF9FTUFJTF9ET01BSU5fJykgJiYgIWUuZW5kc1dpdGgoJ0FQSV9LRVknKSxcbiAgKVxuXG4gIC8vIE1hdGNoIHVwIHRoZSBlbnZzIHdpdGggYXBpIGtleXM6IHsga2V5OiBQQVlMT0FEX0NMT1VEX0VNQUlMX0RPTUFJTl8ke2l9LCB2YWx1ZTogZG9tYWluIH1cbiAgY29uc3QgY3VzdG9tRG9tYWluc1Jlc2VuZE1hcCA9XG4gICAgY3VzdG9tRG9tYWluRW52cz8ucmVkdWNlKFxuICAgICAgKGFjYywgZW52S2V5KSA9PiB7XG4gICAgICAgIGNvbnN0IGFwaUtleSA9IHByb2Nlc3MuZW52W2Ake2VudktleX1fQVBJX0tFWWBdXG4gICAgICAgIGlmICghYXBpS2V5KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYFBBWUxPQURfQ0xPVURfRU1BSUxfRE9NQUlOXyR7ZW52S2V5fSBpcyBtaXNzaW5nIGEgY29ycmVzcG9uZGluZyBQQVlMT0FEX0NMT1VEX0VNQUlMX0RPTUFJTl8ke2VudktleX1fQVBJX0tFWWAsXG4gICAgICAgICAgKVxuICAgICAgICB9XG5cbiAgICAgICAgYWNjW3Byb2Nlc3MuZW52W2VudktleV0gYXMgc3RyaW5nXSA9IG5ldyBSZXNlbmQoYXBpS2V5KVxuICAgICAgICByZXR1cm4gYWNjXG4gICAgICB9LFxuICAgICAge30gYXMgUmVjb3JkPHN0cmluZywgUmVzZW5kPixcbiAgICApIHx8IHt9XG5cbiAgY29uc3QgY3VzdG9tRG9tYWlucyA9IE9iamVjdC5rZXlzKGN1c3RvbURvbWFpbnNSZXNlbmRNYXApXG5cbiAgaWYgKGN1c3RvbURvbWFpbnMubGVuZ3RoKSB7XG4gICAgY29uc29sZS5sb2coXG4gICAgICBgQ29uZmlndXJpbmcgUGF5bG9hZCBDbG91ZCBFbWFpbCBmb3IgJHtbZGVmYXVsdERvbWFpbiwgLi4uKGN1c3RvbURvbWFpbnMgfHwgW10pXS5qb2luKCcsICcpfWAsXG4gICAgKVxuICB9XG5cbiAgY29uc3QgcmVzZW5kRG9tYWluTWFwOiBSZWNvcmQ8c3RyaW5nLCBSZXNlbmQ+ID0ge1xuICAgIFtkZWZhdWx0RG9tYWluXTogbmV3IFJlc2VuZChhcGlLZXkpLFxuICAgIC4uLmN1c3RvbURvbWFpbnNSZXNlbmRNYXAsXG4gIH1cblxuICBjb25zdCBmcm9tTmFtZSA9IGNvbmZpZy5lbWFpbD8uZnJvbU5hbWUgfHwgJ1BheWxvYWQgQ01TJ1xuICBjb25zdCBmcm9tQWRkcmVzcyA9XG4gICAgY29uZmlnLmVtYWlsPy5mcm9tQWRkcmVzcyB8fCBgY21zQCR7Y3VzdG9tRG9tYWlucy5sZW5ndGggPyBjdXN0b21Eb21haW5zWzBdIDogZGVmYXVsdERvbWFpbn1gXG5cbiAgY29uc3QgZXhpc3RpbmdUcmFuc3BvcnQgPSBjb25maWcuZW1haWwgJiYgJ3RyYW5zcG9ydCcgaW4gY29uZmlnLmVtYWlsICYmIGNvbmZpZy5lbWFpbD8udHJhbnNwb3J0XG5cbiAgaWYgKGV4aXN0aW5nVHJhbnNwb3J0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZyb21BZGRyZXNzOiBmcm9tQWRkcmVzcyxcbiAgICAgIGZyb21OYW1lOiBmcm9tTmFtZSxcbiAgICAgIHRyYW5zcG9ydDogZXhpc3RpbmdUcmFuc3BvcnQsXG4gICAgfVxuICB9XG5cbiAgY29uc3QgdHJhbnNwb3J0Q29uZmlnOiBUcmFuc3BvcnRBcmdzID0ge1xuICAgIG5hbWU6ICdwYXlsb2FkLWNsb3VkJyxcbiAgICBzZW5kOiBhc3luYyAobWFpbCwgY2FsbGJhY2spID0+IHtcbiAgICAgIGNvbnN0IHsgZnJvbSwgaHRtbCwgc3ViamVjdCwgdGV4dCwgdG8gfSA9IG1haWwuZGF0YVxuXG4gICAgICBpZiAoIXRvKSByZXR1cm4gY2FsbGJhY2sobmV3IEVycm9yKCdObyBcInRvXCIgYWRkcmVzcyBwcm92aWRlZCcpLCBudWxsKVxuXG4gICAgICBpZiAoIWZyb20pIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoJ05vIFwiZnJvbVwiIGFkZHJlc3MgcHJvdmlkZWQnKSwgbnVsbClcblxuICAgICAgY29uc3QgY2xlYW5Ubzogc3RyaW5nW10gPSBbXVxuICAgICAgY29uc3QgdG9BcnIgPSBBcnJheS5pc0FycmF5KHRvKSA/IHRvIDogW3RvXVxuXG4gICAgICB0b0Fyci5mb3JFYWNoKCh0b0l0ZW0pID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiB0b0l0ZW0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgY2xlYW5Uby5wdXNoKHRvSXRlbSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjbGVhblRvLnB1c2godG9JdGVtLmFkZHJlc3MpXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIGxldCBmcm9tVG9Vc2U6IHN0cmluZ1xuXG4gICAgICBpZiAodHlwZW9mIGZyb20gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGZyb21Ub1VzZSA9IGZyb21cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGZyb20gPT09ICdvYmplY3QnICYmICduYW1lJyBpbiBmcm9tICYmICdhZGRyZXNzJyBpbiBmcm9tKSB7XG4gICAgICAgIGZyb21Ub1VzZSA9IGAke2Zyb20ubmFtZX0gPCR7ZnJvbS5hZGRyZXNzfT5gXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmcm9tVG9Vc2UgPSBgJHtmcm9tTmFtZX0gPCR7ZnJvbUFkZHJlc3N9PmBcbiAgICAgIH1cblxuICAgICAgLy8gUGFyc2UgZG9tYWluLiBDYW4gYmUgaW4gMiBwb3NzaWJsZSBmb3JtYXRzOiAgXCJuYW1lQGRvbWFpbi5jb21cIiBvciBcIkZyaWVuZGx5IE5hbWUgPG5hbWVAZG9tYWluLmNvbT5cIlxuICAgICAgY29uc3QgZG9tYWluTWF0Y2ggPSBmcm9tVG9Vc2UubWF0Y2goLyg/PD1AKVteKFxcc3w+KV0rL2cpXG5cbiAgICAgIGlmICghZG9tYWluTWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcihgQ291bGQgbm90IHBhcnNlIGRvbWFpbiBmcm9tIFwiZnJvbVwiIGFkZHJlc3M6ICR7ZnJvbVRvVXNlfWApLCBudWxsKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBmcm9tRG9tYWluID0gZG9tYWluTWF0Y2hbMF1cbiAgICAgIGNvbnN0IHJlc2VuZCA9IHJlc2VuZERvbWFpbk1hcFtmcm9tRG9tYWluXVxuXG4gICAgICBpZiAoIXJlc2VuZCkge1xuICAgICAgICBjYWxsYmFjayhcbiAgICAgICAgICBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgTm8gUmVzZW5kIGluc3RhbmNlIGZvdW5kIGZvciBkb21haW46ICR7ZnJvbURvbWFpbn0uIEF2YWlsYWJsZSBkb21haW5zOiAke09iamVjdC5rZXlzKFxuICAgICAgICAgICAgICByZXNlbmREb21haW5NYXAsXG4gICAgICAgICAgICApLmpvaW4oJywgJyl9YCxcbiAgICAgICAgICApLFxuICAgICAgICAgIG51bGwsXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgc2VuZFJlc3BvbnNlID0gYXdhaXQgcmVzZW5kLnNlbmRFbWFpbCh7XG4gICAgICAgICAgZnJvbTogZnJvbVRvVXNlLFxuICAgICAgICAgIGh0bWw6IChodG1sIHx8IHRleHQpIGFzIHN0cmluZyxcbiAgICAgICAgICBzdWJqZWN0OiBzdWJqZWN0IHx8ICc8Tm8gc3ViamVjdD4nLFxuICAgICAgICAgIHRvOiBjbGVhblRvLFxuICAgICAgICB9KVxuXG4gICAgICAgIGlmICgnZXJyb3InIGluIHNlbmRSZXNwb25zZSkge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoJ0Vycm9yIHNlbmRpbmcgZW1haWwnLCB7IGNhdXNlOiBzZW5kUmVzcG9uc2UuZXJyb3IgfSksIG51bGwpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHNlbmRSZXNwb25zZSlcbiAgICAgIH0gY2F0Y2ggKGVycjogdW5rbm93bikge1xuICAgICAgICBpZiAoaXNSZXNlbmRFcnJvcihlcnIpKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKFxuICAgICAgICAgICAgbmV3IEVycm9yKGBFcnJvciBzZW5kaW5nIGVtYWlsOiAke2Vyci5zdGF0dXNDb2RlfSAke2Vyci5uYW1lfTogJHtlcnIubWVzc2FnZX1gKSxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgKVxuICAgICAgICB9IGVsc2UgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKFxuICAgICAgICAgICAgbmV3IEVycm9yKGBVbmV4cGVjdGVkIGVycm9yIHNlbmRpbmcgZW1haWw6ICR7ZXJyLm1lc3NhZ2V9OiAke2Vyci5zdGFja31gKSxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgZXJyb3Igc2VuZGluZyBlbWFpbDogJHtlcnJ9YCksIG51bGwpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHZlcnNpb246ICcwLjAuMScsXG4gIH1cblxuICByZXR1cm4ge1xuICAgIGZyb21BZGRyZXNzOiBmcm9tQWRkcmVzcyxcbiAgICBmcm9tTmFtZTogZnJvbU5hbWUsXG4gICAgdHJhbnNwb3J0OiBub2RlbWFpbGVyLmNyZWF0ZVRyYW5zcG9ydCh0cmFuc3BvcnRDb25maWcpLFxuICB9XG59XG5cbnR5cGUgUmVzZW5kRXJyb3IgPSB7XG4gIG1lc3NhZ2U6IHN0cmluZ1xuICBuYW1lOiBzdHJpbmdcbiAgc3RhdHVzQ29kZTogbnVtYmVyXG59XG5cbmZ1bmN0aW9uIGlzUmVzZW5kRXJyb3IoZXJyOiB1bmtub3duKTogZXJyIGlzIFJlc2VuZEVycm9yIHtcbiAgcmV0dXJuIEJvb2xlYW4oXG4gICAgZXJyICYmIHR5cGVvZiBlcnIgPT09ICdvYmplY3QnICYmICdtZXNzYWdlJyBpbiBlcnIgJiYgJ3N0YXR1c0NvZGUnIGluIGVyciAmJiAnbmFtZScgaW4gZXJyLFxuICApXG59XG4iXSwibmFtZXMiOlsicGF5bG9hZENsb3VkRW1haWwiLCJhcmdzIiwicHJvY2VzcyIsImVudiIsIlBBWUxPQURfQ0xPVUQiLCJ1bmRlZmluZWQiLCJhcGlLZXkiLCJFcnJvciIsImRlZmF1bHREb21haW4iLCJjb25maWciLCJjdXN0b21Eb21haW5FbnZzIiwiT2JqZWN0Iiwia2V5cyIsImZpbHRlciIsImUiLCJzdGFydHNXaXRoIiwiZW5kc1dpdGgiLCJjdXN0b21Eb21haW5zUmVzZW5kTWFwIiwicmVkdWNlIiwiYWNjIiwiZW52S2V5IiwiUmVzZW5kIiwiY3VzdG9tRG9tYWlucyIsImxlbmd0aCIsImNvbnNvbGUiLCJsb2ciLCJqb2luIiwicmVzZW5kRG9tYWluTWFwIiwiZnJvbU5hbWUiLCJlbWFpbCIsImZyb21BZGRyZXNzIiwiZXhpc3RpbmdUcmFuc3BvcnQiLCJ0cmFuc3BvcnQiLCJ0cmFuc3BvcnRDb25maWciLCJuYW1lIiwic2VuZCIsIm1haWwiLCJjYWxsYmFjayIsImZyb20iLCJodG1sIiwic3ViamVjdCIsInRleHQiLCJ0byIsImRhdGEiLCJjbGVhblRvIiwidG9BcnIiLCJBcnJheSIsImlzQXJyYXkiLCJmb3JFYWNoIiwidG9JdGVtIiwicHVzaCIsImFkZHJlc3MiLCJmcm9tVG9Vc2UiLCJkb21haW5NYXRjaCIsIm1hdGNoIiwiZnJvbURvbWFpbiIsInJlc2VuZCIsInNlbmRSZXNwb25zZSIsInNlbmRFbWFpbCIsImNhdXNlIiwiZXJyb3IiLCJlcnIiLCJpc1Jlc2VuZEVycm9yIiwic3RhdHVzQ29kZSIsIm1lc3NhZ2UiLCJzdGFjayIsInZlcnNpb24iLCJub2RlbWFpbGVyIiwiY3JlYXRlVHJhbnNwb3J0IiwiQm9vbGVhbiJdLCJtYXBwaW5ncyI6Ijs7OzsrQkFTYUE7OztlQUFBQTs7O21FQVBVO3dCQUNBOzs7Ozs7QUFNaEIsTUFBTUEsb0JBQW9CLENBQUNDO0lBQ2hDLElBQUlDLFFBQVFDLEdBQUcsQ0FBQ0MsYUFBYSxLQUFLLFVBQVUsQ0FBQ0gsTUFBTTtRQUNqRCxPQUFPSTtJQUNUO0lBRUEsSUFBSSxDQUFDSixLQUFLSyxNQUFNLEVBQUUsTUFBTSxJQUFJQyxNQUFNO0lBQ2xDLElBQUksQ0FBQ04s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