"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "LinkButton", {
    enumerable: true,
    get: function() {
        return LinkButton;
    }
});
const _modal = require("@faceless-ui/modal");
const _elements = require("payload/components/elements");
const _forms = require("payload/components/forms");
const _utilities = require("payload/components/utilities");
const _config = require("payload/config");
const _react = /*#__PURE__*/ _interop_require_wildcard(require("react"));
const _reacti18next = require("react-i18next");
const _slate = require("slate");
const _slatereact = require("slate-react");
const _Link = /*#__PURE__*/ _interop_require_default(require("../../../icons/Link"));
const _Button = /*#__PURE__*/ _interop_require_default(require("../../Button"));
const _isActive = /*#__PURE__*/ _interop_require_default(require("../../isActive"));
const _LinkDrawer = require("../LinkDrawer");
const _utilities1 = require("../utilities");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
/**
 * This function is called when an new link is created - not when an existing link is edited.
 */ const insertLink = (editor, fields)=>{
    const isCollapsed = editor.selection && _slate.Range.isCollapsed(editor.selection);
    const data = (0, _forms.reduceFieldsToValues)(fields, true);
    const newLink = {
        children: [],
        doc: data.doc,
        fields: data.fields,
        linkType: data.linkType,
        newTab: data.newTab,
        type: 'link',
        url: data.url
    };
    if (isCollapsed || !editor.selection) {
        // If selection anchor and focus are the same,
        // Just inject a new node with children already set
        _slate.Transforms.insertNodes(editor, {
            ...newLink,
            children: [
                {
                    text: String(data.text)
                }
            ]
        });
    } else if (editor.selection) {
        // Otherwise we need to wrap the selected node in a link,
        // Delete its old text,
        // Move the selection one position forward into the link,
        // And insert the text back into the new link
        _slate.Transforms.wrapNodes(editor, newLink, {
            split: true
        });
        _slate.Transforms.delete(editor, {
            at: editor.selection.focus.path,
            unit: 'word'
        });
        _slate.Transforms.move(editor, {
            distance: 1,
            unit: 'offset'
        });
        _slate.Transforms.insertText(editor, String(data.text), {
            at: editor.selection.focus.path
        });
    }
    _slatereact.ReactEditor.focus(editor);
};
const LinkButton = ({ fieldProps })=>{
    const customFieldSchema = fieldProps?.admin?.link?.fields;
    const { user } = (0, _utilities.useAuth)();
    const { code: locale } = (0, _utilities.useLocale)();
    const [initialState, setInitialState] = (0, _react.useState)({});
    const { i18n, t } = (0, _reacti18next.useTranslation)([
        'upload',
        'general'
    ]);
    const editor = (0, _slatereact.useSlate)();
    const config = (0, _utilities.useConfig)();
    const [fieldSchema] = (0, _react.useState)(()=>{
        const fieldsUnsanitized = (0, _utilities1.transformExtraFields)(customFieldSchema, config, i18n);
        // Sanitize custom fields here
        const validRelationships = config.collections.map((c)=>c.slug) || [];
        const fields = (0, _config.sanitizeFields)({
            config: config,
            fields: fieldsUnsanitized,
            validRelationships
        });
        return fields;
    });
    const { closeModal, openModal } = (0, _modal.useModal)();
    const drawerSlug = (0, _elements.useDrawerSlug)('rich-text-link');
    const { getDocPreferences } = (0, _utilities.useDocumentInfo)();
    return /*#__PURE__*/ _react.default.createElement(_react.Fragment, null, /*#__PURE__*/ _react.default.createElement(_Button.default, {
        className: "link",
        format: "link",
        onClick: async ()=>{
            if ((0, _isActive.default)(editor, 'link')) {
                (0, _utilities1.unwrapLink)(editor);
            } else {
                openModal(drawerSlug);
                const isCollapsed = editor.selection && _slate.Range.isCollapsed(editor.selection);
                if (!isCollapsed) {
                    const data = {
                        text: editor.selection ? _slate.Editor.string(editor, editor.selection) : ''
                    };
                    const preferences = await getDocPreferences();
                    const state = await (0, _utilities.buildStateFromSchema)({
                        config,
                        data,
                        fieldSchema,
                        locale,
                        operation: 'create',
                        preferences,
                        t,
                        user
                    });
                    setInitialState(state);
                }
            }
        },
        tooltip: t('fields:addLink')
    }, /*#__PURE__*/ _react.default.createElement(_Link.default, null)), /*#__PURE__*/ _react.default.createElement(_LinkDrawer.LinkDrawer, {
        drawerSlug: drawerSlug,
        fieldSchema: fieldSchema,
        handleClose: ()=>{
            closeModal(drawerSlug);
        },
        handleModalSubmit: (fields)=>{
            insertLink(editor, fields);
            closeModal(drawerSlug);
        },
        initialState: initialState
    }));
};

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9maWVsZC9lbGVtZW50cy9saW5rL0J1dHRvbi9pbmRleC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBGaWVsZHMgfSBmcm9tICdwYXlsb2FkL3R5cGVzJ1xuXG5pbXBvcnQgeyB1c2VNb2RhbCB9IGZyb20gJ0BmYWNlbGVzcy11aS9tb2RhbCdcbmltcG9ydCB7IHVzZURyYXdlclNsdWcgfSBmcm9tICdwYXlsb2FkL2NvbXBvbmVudHMvZWxlbWVudHMnXG5pbXBvcnQgeyByZWR1Y2VGaWVsZHNUb1ZhbHVlcyB9IGZyb20gJ3BheWxvYWQvY29tcG9uZW50cy9mb3JtcydcbmltcG9ydCB7XG4gIGJ1aWxkU3RhdGVGcm9tU2NoZW1hLFxuICB1c2VBdXRoLFxuICB1c2VDb25maWcsXG4gIHVzZURvY3VtZW50SW5mbyxcbiAgdXNlTG9jYWxlLFxufSBmcm9tICdwYXlsb2FkL2NvbXBvbmVudHMvdXRpbGl0aWVzJ1xuaW1wb3J0IHsgc2FuaXRpemVGaWVsZHMgfSBmcm9tICdwYXlsb2FkL2NvbmZpZydcbmltcG9ydCBSZWFjdCwgeyBGcmFnbWVudCwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCdcbmltcG9ydCB7IHVzZVRyYW5zbGF0aW9uIH0gZnJvbSAncmVhY3QtaTE4bmV4dCdcbmltcG9ydCB7IEVkaXRvciwgUmFuZ2UsIFRyYW5zZm9ybXMgfSBmcm9tICdzbGF0ZSdcbmltcG9ydCB7IFJlYWN0RWRpdG9yLCB1c2VTbGF0ZSB9IGZyb20gJ3NsYXRlLXJlYWN0J1xuXG5pbXBvcnQgdHlwZSB7IEZpZWxkUHJvcHMgfSBmcm9tICcuLi8uLi8uLi8uLi90eXBlcydcblxuaW1wb3J0IExpbmtJY29uIGZyb20gJy4uLy4uLy4uL2ljb25zL0xpbmsnXG5pbXBvcnQgRWxlbWVudEJ1dHRvbiBmcm9tICcuLi8uLi9CdXR0b24nXG5pbXBvcnQgaXNFbGVtZW50QWN0aXZlIGZyb20gJy4uLy4uL2lzQWN0aXZlJ1xuaW1wb3J0IHsgTGlua0RyYXdlciB9IGZyb20gJy4uL0xpbmtEcmF3ZXInXG5pbXBvcnQgeyB0cmFuc2Zvcm1FeHRyYUZpZWxkcywgdW53cmFwTGluayB9IGZyb20gJy4uL3V0aWxpdGllcydcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aGVuIGFuIG5ldyBsaW5rIGlzIGNyZWF0ZWQgLSBub3Qgd2hlbiBhbiBleGlzdGluZyBsaW5rIGlzIGVkaXRlZC5cbiAqL1xuY29uc3QgaW5zZXJ0TGluayA9IChlZGl0b3IsIGZpZWxkcykgPT4ge1xuICBjb25zdCBpc0NvbGxhcHNlZCA9IGVkaXRvci5zZWxlY3Rpb24gJiYgUmFuZ2UuaXNDb2xsYXBzZWQoZWRpdG9yLnNlbGVjdGlvbilcbiAgY29uc3QgZGF0YSA9IHJlZHVjZUZpZWxkc1RvVmFsdWVzKGZpZWxkcywgdHJ1ZSlcblxuICBjb25zdCBuZXdMaW5rID0ge1xuICAgIGNoaWxkcmVuOiBbXSxcbiAgICBkb2M6IGRhdGEuZG9jLFxuICAgIGZpZWxkczogZGF0YS5maWVsZHMsIC8vIEFueSBjdXN0b20gdXNlci1hZGRlZCBmaWVsZHMgYXJlIHBhcnQgb2YgZGF0YS5maWVsZHNcbiAgICBsaW5rVHlwZTogZGF0YS5saW5rVHlwZSxcbiAgICBuZXdUYWI6IGRhdGEubmV3VGFiLFxuICAgIHR5cGU6ICdsaW5rJyxcbiAgICB1cmw6IGRhdGEudXJsLFxuICB9XG5cbiAgaWYgKGlzQ29sbGFwc2VkIHx8ICFlZGl0b3Iuc2VsZWN0aW9uKSB7XG4gICAgLy8gSWYgc2VsZWN0aW9uIGFuY2hvciBhbmQgZm9jdXMgYXJlIHRoZSBzYW1lLFxuICAgIC8vIEp1c3QgaW5qZWN0IGEgbmV3IG5vZGUgd2l0aCBjaGlsZHJlbiBhbHJlYWR5IHNldFxuICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAuLi5uZXdMaW5rLFxuICAgICAgY2hpbGRyZW46IFt7IHRleHQ6IFN0cmluZyhkYXRhLnRleHQpIH1dLFxuICAgIH0pXG4gIH0gZWxzZSBpZiAoZWRpdG9yLnNlbGVjdGlvbikge1xuICAgIC8vIE90aGVyd2lzZSB3ZSBuZWVkIHRvIHdyYXAgdGhlIHNlbGVjdGVkIG5vZGUgaW4gYSBsaW5rLFxuICAgIC8vIERlbGV0ZSBpdHMgb2xkIHRleHQsXG4gICAgLy8gTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBwb3NpdGlvbiBmb3J3YXJkIGludG8gdGhlIGxpbmssXG4gICAgLy8gQW5kIGluc2VydCB0aGUgdGV4dCBiYWNrIGludG8gdGhlIG5ldyBsaW5rXG4gICAgVHJhbnNmb3Jtcy53cmFwTm9kZXMoZWRpdG9yLCBuZXdMaW5rLCB7IHNwbGl0OiB0cnVlIH0pXG4gICAgVHJhbnNmb3Jtcy5kZWxldGUoZWRpdG9yLCB7IGF0OiBlZGl0b3Iuc2VsZWN0aW9uLmZvY3VzLnBhdGgsIHVuaXQ6ICd3b3JkJyB9KVxuICAgIFRyYW5zZm9ybXMubW92ZShlZGl0b3IsIHsgZGlzdGFuY2U6IDEsIHVuaXQ6ICdvZmZzZXQnIH0pXG4gICAgVHJhbnNmb3Jtcy5pbnNlcnRUZXh0KGVkaXRvciwgU3RyaW5nKGRhdGEudGV4dCksIHsgYXQ6IGVkaXRvci5zZWxlY3Rpb24uZm9jdXMucGF0aCB9KVxuICB9XG5cbiAgUmVhY3RFZGl0b3IuZm9jdXMoZWRpdG9yKVxufVxuXG5leHBvcnQgY29uc3QgTGlua0J1dHRvbjogUmVhY3QuRkM8e1xuICBmaWVsZFByb3BzOiBGaWVsZFByb3BzXG4gIHBhdGg6IHN0cmluZ1xufT4gPSAoeyBmaWVsZFByb3BzIH0pID0+IHtcbiAgY29uc3QgY3VzdG9tRmllbGRTY2hlbWEgPSBmaWVsZFByb3BzPy5hZG1pbj8ubGluaz8uZmllbGRzXG4gIGNvbnN0IHsgdXNlciB9ID0gdXNlQXV0aCgpXG4gIGNvbnN0IHsgY29kZTogbG9jYWxlIH0gPSB1c2VMb2NhbGUoKVxuICBjb25zdCBbaW5pdGlhbFN0YXRlLCBzZXRJbml0aWFsU3RhdGVdID0gdXNlU3RhdGU8RmllbGRzPih7fSlcblxuICBjb25zdCB7IGkxOG4sIHQgfSA9IHVzZVRyYW5zbGF0aW9uKFsndXBsb2FkJywgJ2dlbmVyYWwnXSlcbiAgY29uc3QgZWRpdG9yID0gdXNlU2xhdGUoKVxuICBjb25zdCBjb25maWcgPSB1c2VDb25maWcoKVxuXG4gIGNvbnN0IFtmaWVsZFNjaGVtYV0gPSB1c2VTdGF0ZSgoKSA9PiB7XG4gICAgY29uc3QgZmllbGRzVW5zYW5pdGl6ZWQgPSB0cmFuc2Zvcm1FeHRyYUZpZWxkcyhjdXN0b21GaWVsZFNjaGVtYSwgY29uZmlnLCBpMThuKVxuICAgIC8vIFNhbml0aXplIGN1c3RvbSBmaWVsZHMgaGVyZVxuICAgIGNvbnN0IHZhbGlkUmVsYXRpb25zaGlwcyA9IGNvbmZpZy5jb2xsZWN0aW9ucy5tYXAoKGMpID0+IGMuc2x1ZykgfHwgW11cbiAgICBjb25zdCBmaWVsZHMgPSBzYW5pdGl6ZUZpZWxkcyh7XG4gICAgICBjb25maWc6IGNvbmZpZyxcbiAgICAgIGZpZWxkczogZmllbGRzVW5zYW5pdGl6ZWQsXG4gICAgICB2YWxpZFJlbGF0aW9uc2hpcHMsXG4gICAgfSlcblxuICAgIHJldHVybiBmaWVsZHNcbiAgfSlcblxuICBjb25zdCB7IGNsb3NlTW9kYWwsIG9wZW5Nb2RhbCB9ID0gdXNlTW9kYWwoKVxuICBjb25zdCBkcmF3ZXJTbHVnID0gdXNlRHJhd2VyU2x1ZygncmljaC10ZXh0LWxpbmsnKVxuICBjb25zdCB7IGdldERvY1ByZWZlcmVuY2VzIH0gPSB1c2VEb2N1bWVudEluZm8oKVxuXG4gIHJldHVybiAoXG4gICAgPEZyYWdtZW50PlxuICAgICAgPEVsZW1lbnRCdXR0b25cbiAgICAgICAgY2xhc3NOYW1lPVwibGlua1wiXG4gICAgICAgIGZvcm1hdD1cImxpbmtcIlxuICAgICAgICBvbkNsaWNrPXthc3luYyAoKSA9PiB7XG4gICAgICAgICAgaWYgKGlzRWxlbWVudEFjdGl2ZShlZGl0b3IsICdsaW5rJykpIHtcbiAgICAgICAgICAgIHVud3JhcExpbmsoZWRpdG9yKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvcGVuTW9kYWwoZHJhd2VyU2x1ZylcblxuICAgICAgICAgICAgY29uc3QgaXNDb2xsYXBzZWQgPSBlZGl0b3Iuc2VsZWN0aW9uICYmIFJhbmdlLmlzQ29sbGFwc2VkKGVkaXRvci5zZWxlY3Rpb24pXG5cbiAgICAgICAgICAgIGlmICghaXNDb2xsYXBzZWQpIHtcbiAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBlZGl0b3Iuc2VsZWN0aW9uID8gRWRpdG9yLnN0cmluZyhlZGl0b3IsIGVkaXRvci5zZWxlY3Rpb24pIDogJycsXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjb25zdCBwcmVmZXJlbmNlcyA9IGF3YWl0IGdldERvY1ByZWZlcmVuY2VzKClcbiAgICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSBhd2FpdCBidWlsZFN0YXRlRnJvbVNjaGVtYSh7XG4gICAgICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICAgZmllbGRTY2hlbWEsXG4gICAgICAgICAgICAgICAgbG9jYWxlLFxuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogJ2NyZWF0ZScsXG4gICAgICAgICAgICAgICAgcHJlZmVyZW5jZXMsXG4gICAgICAgICAgICAgICAgdCxcbiAgICAgICAgICAgICAgICB1c2VyLFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICBzZXRJbml0aWFsU3RhdGUoc3RhdGUpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9fVxuICAgICAgICB0b29sdGlwPXt0KCdmaWVsZHM6YWRkTGluaycpfVxuICAgICAgPlxuICAgICAgICA8TGlua0ljb24gLz5cbiAgICAgIDwvRWxlbWVudEJ1dHRvbj5cbiAgICAgIDxMaW5rRHJhd2VyXG4gICAgICAgIGRyYXdlclNsdWc9e2RyYXdlclNsdWd9XG4gICAgICAgIGZpZWxkU2NoZW1hPXtmaWVsZFNjaGVtYX1cbiAgICAgICAgaGFuZGxlQ2xvc2U9eygpID0+IHtcbiAgICAgICAgICBjbG9zZU1vZGFsKGRyYXdlclNsdWcpXG4gICAgICAgIH19XG4gICAgICAgIGhhbmRsZU1vZGFsU3VibWl0PXsoZmllbGRzKSA9PiB7XG4gICAgICAgICAgaW5zZXJ0TGluayhlZGl0b3IsIGZpZWxkcylcbiAgICAgICAgICBjbG9zZU1vZGFsKGRyYXdlclNsdWcpXG4gICAgICAgIH19XG4gICAgICAgIGluaXRpYWxTdGF0ZT17aW5pdGlhbFN0YXRlfVxuICAgICAgLz5cbiAgICA8L0ZyYWdtZW50PlxuICApXG59XG4iXSwibmFtZXMiOlsiTGlua0J1dHRvbiIsImluc2VydExpbmsiLCJlZGl0b3IiLCJmaWVsZHMiLCJpc0NvbGxhcHNlZCIsInNlbGVjdGlvbiIsIlJhbmdlIiwiZGF0YSIsInJlZHVjZUZpZWxkc1RvVmFsdWVzIiwibmV3TGluayIsImNoaWxkcmVuIiwiZG9jIiwibGlua1R5cGUiLCJuZXdUYWIiLCJ0eXBlIiwidXJsIiwiVHJhbnNmb3JtcyIsImluc2VydE5vZGVzIiwidGV4dCIsIlN0cmluZyIsIndyYXBOb2RlcyIsInNwbGl0IiwiZGVsZXRlIiwiYXQiLCJmb2N1cyIsInBhdGgiLCJ1bml0IiwibW92ZSIsImRpc3RhbmNlIiwiaW5zZXJ0VGV4dCIsIlJlYWN0RWRpdG9yIiwiZmllbGRQcm9wcyIsImN1c3RvbUZpZWxkU2NoZW1hIiwiYWRtaW4iLCJsaW5rIiwidXNlciIsInVzZUF1dGgiLCJjb2RlIiwibG9jYWxlIiwidXNlTG9jYWxlIiwiaW5pdGlhbFN0YXRlIiwic2V0SW5pdGlhbFN0YXRlIiwidXNlU3RhdGUiLCJpMThuIiwidCIsInVzZVRyYW5zbGF0aW9uIiwidXNlU2xhdGUiLCJjb25maWciLCJ1c2VDb25maWciLCJmaWVsZFNjaGVtYSIsImZpZWxkc1Vuc2FuaXRpemVkIiwidHJhbnNmb3JtRXh0cmFGaWVsZHMiLCJ2YWxpZFJlbGF0aW9uc2hpcHMiLCJjb2xsZWN0aW9ucyIsIm1hcCIsImMiLCJzbHVnIiwic2FuaXRpemVGaWVsZHMiLCJjbG9zZU1vZGFsIiwib3Blbk1vZGFsIiwidXNlTW9kYWwiLCJkcmF3ZXJTbHVnIiwidXNlRHJhd2VyU2x1ZyIsImdldERvY1ByZWZlcmVuY2VzIiwidXNlRG9jdW1lbnRJbmZvIiwiRnJhZ21lbnQiLCJFbGVtZW50QnV0dG9uIiwiY2xhc3NOYW1lIiwiZm9ybWF0Iiwib25DbGljayIsImlzRWxlbWVudEFjdGl2ZSIsInVud3JhcExpbmsiLCJFZGl0b3IiLCJzdHJpbmciLCJwcmVmZXJlbmNlcyIsInN0YXRlIiwiYnVpbGRTdGF0ZUZyb21TY2hlbWEiLCJvcGVyYXRpb24iLCJ0b29sdGlwIiwiTGlua0ljb24iLCJMaW5rRHJhd2VyIiwiaGFuZGxlQ2xvc2UiLCJoYW5kbGVNb2RhbFN1Ym1pdCJdLCJtYXBwaW5ncyI6Ijs7OzsrQkFnRWFBOzs7ZUFBQUE7Ozt1QkE5RFk7MEJBQ0s7dUJBQ087MkJBTzlCO3dCQUN3QjsrREFDVzs4QkFDWDt1QkFDVzs0QkFDSjs2REFJakI7K0RBQ0s7aUVBQ0U7NEJBQ0Q7NEJBQ3NCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFakQ7O0NBRUMsR0FDRCxNQUFNQyxhQUFhLENBQUNDLFFBQVFDO0lBQzFCLE1BQU1DLGNBQWNGLE9BQU9HLFNBQVMsSUFBSUMsWUFBSyxDQUFDRixXQUFXLENBQUNGLE9BQU9HLFNBQVM7SUFDMUUsTUFBTUUsT0FBT0MsSUFBQUEsMkJBQW9CLEVBQUNMLFFBQVE7SUFFMUMsTUFBTU0sVUFBVTtRQUNkQyxVQUFVLEVBQUU7UUFDWkMsS0FBS0osS0FBS0ksR0FBRztRQUNiUixRQUFRSSxLQUFLSixNQUFNO1FBQ25CUyxVQUFVTCxLQUFLSyxRQUFRO1FBQ3ZCQyxRQUFRTixLQUFLTSxNQUFNO1FBQ25CQyxNQUFNO1FBQ05DLEtBQUtSLEtBQUtRLEdBQUc7SUFDZjtJQUVBLElBQUlYLGVBQWUsQ0FBQ0YsT0FBT0csU0FBUyxFQUFFO1FBQ3BDLDhDQUE4QztRQUM5QyxtREFBbUQ7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