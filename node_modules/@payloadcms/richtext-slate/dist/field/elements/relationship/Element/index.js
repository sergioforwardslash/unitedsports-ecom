"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
const _components = require("payload/components");
const _elements = require("payload/components/elements");
const _hooks = require("payload/components/hooks");
const _utilities = require("payload/components/utilities");
const _utilities1 = require("payload/utilities");
const _react = /*#__PURE__*/ _interop_require_wildcard(require("react"));
const _reacti18next = require("react-i18next");
const _slate = require("slate");
const _slatereact = require("slate-react");
const _EnabledRelationshipsCondition = require("../../EnabledRelationshipsCondition");
require("./index.scss");
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const baseClass = 'rich-text-relationship';
const initialParams = {
    depth: 0
};
const Element = (props)=>{
    const { attributes, children, element, element: { relationTo, value }, fieldProps } = props;
    const { collections, routes: { api }, serverURL } = (0, _utilities.useConfig)();
    const [enabledCollectionSlugs] = (0, _react.useState)(()=>collections.filter(({ admin: { enableRichTextRelationship } })=>enableRichTextRelationship).map(({ slug })=>slug));
    const [relatedCollection, setRelatedCollection] = (0, _react.useState)(()=>collections.find((coll)=>coll.slug === relationTo));
    const selected = (0, _slatereact.useSelected)();
    const focused = (0, _slatereact.useFocused)();
    const { i18n, t } = (0, _reacti18next.useTranslation)([
        'fields',
        'general'
    ]);
    const editor = (0, _slatereact.useSlateStatic)();
    const [cacheBust, dispatchCacheBust] = (0, _react.useReducer)((state)=>state + 1, 0);
    const [{ data }, { setParams }] = (0, _hooks.usePayloadAPI)(`${serverURL}${api}/${relatedCollection.slug}/${value?.id}`, {
        initialParams
    });
    const [DocumentDrawer, DocumentDrawerToggler, { closeDrawer }] = (0, _elements.useDocumentDrawer)({
        id: value?.id,
        collectionSlug: relatedCollection.slug
    });
    const [ListDrawer, ListDrawerToggler, { closeDrawer: closeListDrawer }] = (0, _elements.useListDrawer)({
        collectionSlugs: enabledCollectionSlugs,
        selectedCollection: relatedCollection.slug
    });
    const removeRelationship = (0, _react.useCallback)(()=>{
        const elementPath = _slatereact.ReactEditor.findPath(editor, element);
        _slate.Transforms.removeNodes(editor, {
            at: elementPath
        });
    }, [
        editor,
        element
    ]);
    const updateRelationship = _react.default.useCallback(({ doc })=>{
        const elementPath = _slatereact.ReactEditor.findPath(editor, element);
        _slate.Transforms.setNodes(editor, {
            children: [
                {
                    text: ' '
                }
            ],
            relationTo: relatedCollection.slug,
            type: 'relationship',
            value: {
                id: doc.id
            }
        }, {
            at: elementPath
        });
        setParams({
            ...initialParams,
            cacheBust
        });
        closeDrawer();
        dispatchCacheBust();
    }, [
        editor,
        element,
        relatedCollection,
        cacheBust,
        setParams,
        closeDrawer
    ]);
    const swapRelationship = _react.default.useCallback(({ collectionConfig, docID })=>{
        const elementPath = _slatereact.ReactEditor.findPath(editor, element);
        _slate.Transforms.setNodes(editor, {
            children: [
                {
                    text: ' '
                }
            ],
            relationTo: collectionConfig.slug,
            type: 'relationship',
            value: {
                id: docID
            }
        }, {
            at: elementPath
        });
        setRelatedCollection(collections.find((coll)=>coll.slug === collectionConfig.slug));
        setParams({
            ...initialParams,
            cacheBust
        });
        closeListDrawer();
        dispatchCacheBust();
    }, [
        closeListDrawer,
        editor,
        element,
        cacheBust,
        setParams,
        collections
    ]);
    return /*#__PURE__*/ _react.default.createElement("div", {
        className: [
            baseClass,
            selected && focused && `${baseClass}--selected`
        ].filter(Boolean).join(' '),
        contentEditable: false,
        ...attributes
    }, /*#__PURE__*/ _react.default.createElement("div", {
        className: `${baseClass}__wrap`
    }, /*#__PURE__*/ _react.default.createElement("p", {
        className: `${baseClass}__label`
    }, t('labelRelationship', {
        label: (0, _utilities1.getTranslation)(relatedCollection.labels.singular, i18n)
    })), /*#__PURE__*/ _react.default.createElement(DocumentDrawerToggler, {
        className: `${baseClass}__doc-drawer-toggler`
    }, /*#__PURE__*/ _react.default.createElement("p", {
        className: `${baseClass}__title`
    }, data[relatedCollection?.admin?.useAsTitle || 'id']))), /*#__PURE__*/ _react.default.createElement("div", {
        className: `${baseClass}__actions`
    }, /*#__PURE__*/ _react.default.createElement(ListDrawerToggler, {
        className: `${baseClass}__list-drawer-toggler`,
        disabled: fieldProps?.admin?.readOnly
    }, /*#__PURE__*/ _react.default.createElement(_components.Button, {
        buttonStyle: "icon-label",
        disabled: fieldProps?.admin?.readOnly,
        el: "div",
        icon: "swap",
        onClick: ()=>{
        // do nothing
        },
        round: true,
        tooltip: t('swapRelationship')
    })), /*#__PURE__*/ _react.default.createElement(_components.Button, {
        buttonStyle: "icon-label",
        className: `${baseClass}__removeButton`,
        disabled: fieldProps?.admin?.readOnly,
        icon: "x",
        onClick: (e)=>{
            e.preventDefault();
            removeRelationship();
        },
        round: true,
        tooltip: t('fields:removeRelationship')
    })), value?.id && /*#__PURE__*/ _react.default.createElement(DocumentDrawer, {
        onSave: updateRelationship
    }), /*#__PURE__*/ _react.default.createElement(ListDrawer, {
        onSelect: swapRelationship
    }), children);
};
const _default = (props)=>{
    return /*#__PURE__*/ _react.default.createElement(_EnabledRelationshipsCondition.EnabledRelationshipsCondition, props, /*#__PURE__*/ _react.default.createElement(Element, props));
};

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9maWVsZC9lbGVtZW50cy9yZWxhdGlvbnNoaXAvRWxlbWVudC9pbmRleC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBIVE1MQXR0cmlidXRlcyB9IGZyb20gJ3JlYWN0J1xuXG5pbXBvcnQgeyBCdXR0b24gfSBmcm9tICdwYXlsb2FkL2NvbXBvbmVudHMnXG5pbXBvcnQgeyB1c2VEb2N1bWVudERyYXdlciwgdXNlTGlzdERyYXdlciB9IGZyb20gJ3BheWxvYWQvY29tcG9uZW50cy9lbGVtZW50cydcbmltcG9ydCB7IHVzZVBheWxvYWRBUEkgfSBmcm9tICdwYXlsb2FkL2NvbXBvbmVudHMvaG9va3MnXG5pbXBvcnQgeyB1c2VDb25maWcgfSBmcm9tICdwYXlsb2FkL2NvbXBvbmVudHMvdXRpbGl0aWVzJ1xuaW1wb3J0IHsgZ2V0VHJhbnNsYXRpb24gfSBmcm9tICdwYXlsb2FkL3V0aWxpdGllcydcbmltcG9ydCBSZWFjdCwgeyB1c2VDYWxsYmFjaywgdXNlUmVkdWNlciwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCdcbmltcG9ydCB7IHVzZVRyYW5zbGF0aW9uIH0gZnJvbSAncmVhY3QtaTE4bmV4dCdcbmltcG9ydCB7IFRyYW5zZm9ybXMgfSBmcm9tICdzbGF0ZSdcbmltcG9ydCB7IFJlYWN0RWRpdG9yLCB1c2VGb2N1c2VkLCB1c2VTZWxlY3RlZCwgdXNlU2xhdGVTdGF0aWMgfSBmcm9tICdzbGF0ZS1yZWFjdCdcblxuaW1wb3J0IHR5cGUgeyBGaWVsZFByb3BzIH0gZnJvbSAnLi4vLi4vLi4vLi4vdHlwZXMnXG5cbmltcG9ydCB7IEVuYWJsZWRSZWxhdGlvbnNoaXBzQ29uZGl0aW9uIH0gZnJvbSAnLi4vLi4vRW5hYmxlZFJlbGF0aW9uc2hpcHNDb25kaXRpb24nXG5pbXBvcnQgJy4vaW5kZXguc2NzcydcblxuY29uc3QgYmFzZUNsYXNzID0gJ3JpY2gtdGV4dC1yZWxhdGlvbnNoaXAnXG5cbmNvbnN0IGluaXRpYWxQYXJhbXMgPSB7XG4gIGRlcHRoOiAwLFxufVxuXG50eXBlIFByb3BzID0ge1xuICBhdHRyaWJ1dGVzOiBIVE1MQXR0cmlidXRlczxIVE1MRGl2RWxlbWVudD5cbiAgY2hpbGRyZW46IFJlYWN0LlJlYWN0Tm9kZVxuICBlbGVtZW50OiBhbnlcbiAgZmllbGRQcm9wczogRmllbGRQcm9wc1xufVxuY29uc3QgRWxlbWVudDogUmVhY3QuRkM8UHJvcHM+ID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBhdHRyaWJ1dGVzLFxuICAgIGNoaWxkcmVuLFxuICAgIGVsZW1lbnQsXG4gICAgZWxlbWVudDogeyByZWxhdGlvblRvLCB2YWx1ZSB9LFxuICAgIGZpZWxkUHJvcHMsXG4gIH0gPSBwcm9wc1xuXG4gIGNvbnN0IHtcbiAgICBjb2xsZWN0aW9ucyxcbiAgICByb3V0ZXM6IHsgYXBpIH0sXG4gICAgc2VydmVyVVJMLFxuICB9ID0gdXNlQ29uZmlnKClcbiAgY29uc3QgW2VuYWJsZWRDb2xsZWN0aW9uU2x1Z3NdID0gdXNlU3RhdGUoKCkgPT5cbiAgICBjb2xsZWN0aW9uc1xuICAgICAgLmZpbHRlcigoeyBhZG1pbjogeyBlbmFibGVSaWNoVGV4dFJlbGF0aW9uc2hpcCB9IH0pID0+IGVuYWJsZVJpY2hUZXh0UmVsYXRpb25zaGlwKVxuICAgICAgLm1hcCgoeyBzbHVnIH0pID0+IHNsdWcpLFxuICApXG4gIGNvbnN0IFtyZWxhdGVkQ29sbGVjdGlvbiwgc2V0UmVsYXRlZENvbGxlY3Rpb25dID0gdXNlU3RhdGUoKCkgPT5cbiAgICBjb2xsZWN0aW9ucy5maW5kKChjb2xsKSA9PiBjb2xsLnNsdWcgPT09IHJlbGF0aW9uVG8pLFxuICApXG4gIGNvbnN0IHNlbGVjdGVkID0gdXNlU2VsZWN0ZWQoKVxuICBjb25zdCBmb2N1c2VkID0gdXNlRm9jdXNlZCgpXG4gIGNvbnN0IHsgaTE4biwgdCB9ID0gdXNlVHJhbnNsYXRpb24oWydmaWVsZHMnLCAnZ2VuZXJhbCddKVxuICBjb25zdCBlZGl0b3IgPSB1c2VTbGF0ZVN0YXRpYygpXG4gIGNvbnN0IFtjYWNoZUJ1c3QsIGRpc3BhdGNoQ2FjaGVCdXN0XSA9IHVzZVJlZHVjZXIoKHN0YXRlKSA9PiBzdGF0ZSArIDEsIDApXG4gIGNvbnN0IFt7IGRhdGEgfSwgeyBzZXRQYXJhbXMgfV0gPSB1c2VQYXlsb2FkQVBJKFxuICAgIGAke3NlcnZlclVSTH0ke2FwaX0vJHtyZWxhdGVkQ29sbGVjdGlvbi5zbHVnfS8ke3ZhbHVlPy5pZH1gLFxuICAgIHsgaW5pdGlhbFBhcmFtcyB9LFxuICApXG5cbiAgY29uc3QgW0RvY3VtZW50RHJhd2VyLCBEb2N1bWVudERyYXdlclRvZ2dsZXIsIHsgY2xvc2VEcmF3ZXIgfV0gPSB1c2VEb2N1bWVudERyYXdlcih7XG4gICAgaWQ6IHZhbHVlPy5pZCxcbiAgICBjb2xsZWN0aW9uU2x1ZzogcmVsYXRlZENvbGxlY3Rpb24uc2x1ZyxcbiAgfSlcblxuICBjb25zdCBbTGlzdERyYXdlciwgTGlzdERyYXdlclRvZ2dsZXIsIHsgY2xvc2VEcmF3ZXI6IGNsb3NlTGlzdERyYXdlciB9XSA9IHVzZUxpc3REcmF3ZXIoe1xuICAgIGNvbGxlY3Rpb25TbHVnczogZW5hYmxlZENvbGxlY3Rpb25TbHVncyxcbiAgICBzZWxlY3RlZENvbGxlY3Rpb246IHJlbGF0ZWRDb2xsZWN0aW9uLnNsdWcsXG4gIH0pXG5cbiAgY29uc3QgcmVtb3ZlUmVsYXRpb25zaGlwID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGNvbnN0IGVsZW1lbnRQYXRoID0gUmVhY3RFZGl0b3IuZmluZFBhdGgoZWRpdG9yLCBlbGVtZW50KVxuXG4gICAgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHsgYXQ6IGVsZW1lbnRQYXRoIH0pXG4gIH0sIFtlZGl0b3IsIGVsZW1lbnRdKVxuXG4gIGNvbnN0IHVwZGF0ZVJlbGF0aW9uc2hpcCA9IFJlYWN0LnVzZUNhbGxiYWNrKFxuICAgICh7IGRvYyB9KSA9PiB7XG4gICAgICBjb25zdCBlbGVtZW50UGF0aCA9IFJlYWN0RWRpdG9yLmZpbmRQYXRoKGVkaXRvciwgZWxlbWVudClcblxuICAgICAgVHJhbnNmb3Jtcy5zZXROb2RlcyhcbiAgICAgICAgZWRpdG9yLFxuICAgICAgICB7XG4gICAgICAgICAgY2hpbGRyZW46IFt7IHRleHQ6ICcgJyB9XSxcbiAgICAgICAgICByZWxhdGlvblRvOiByZWxhdGVkQ29sbGVjdGlvbi5zbHVnLFxuICAgICAgICAgIHR5cGU6ICdyZWxhdGlvbnNoaXAnLFxuICAgICAgICAgIHZhbHVlOiB7IGlkOiBkb2MuaWQgfSxcbiAgICAgICAgfSxcbiAgICAgICAgeyBhdDogZWxlbWVudFBhdGggfSxcbiAgICAgIClcblxuICAgICAgc2V0UGFyYW1zKHtcbiAgICAgICAgLi4uaW5pdGlhbFBhcmFtcyxcbiAgICAgICAgY2FjaGVCdXN0LCAvLyBkbyB0aGlzIHRvIGdldCB0aGUgdXNlUGF5bG9hZEFQSSB0byByZS1mZXRjaCB0aGUgZGF0YSBldmVuIHRob3VnaCB0aGUgVVJMIHN0cmluZyBoYXNuJ3QgY2hhbmdlZFxuICAgICAgfSlcblxuICAgICAgY2xvc2VEcmF3ZXIoKVxuICAgICAgZGlzcGF0Y2hDYWNoZUJ1c3QoKVxuICAgIH0sXG4gICAgW2VkaXRvciwgZWxlbWVudCwgcmVsYXRlZENvbGxlY3Rpb24sIGNhY2hlQnVzdCwgc2V0UGFyYW1zLCBjbG9zZURyYXdlcl0sXG4gIClcblxuICBjb25zdCBzd2FwUmVsYXRpb25zaGlwID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgKHsgY29sbGVjdGlvbkNvbmZpZywgZG9jSUQgfSkgPT4ge1xuICAgICAgY29uc3QgZWxlbWVudFBhdGggPSBSZWFjdEVkaXRvci5maW5kUGF0aChlZGl0b3IsIGVsZW1lbnQpXG5cbiAgICAgIFRyYW5zZm9ybXMuc2V0Tm9kZXMoXG4gICAgICAgIGVkaXRvcixcbiAgICAgICAge1xuICAgICAgICAgIGNoaWxkcmVuOiBbeyB0ZXh0OiAnICcgfV0sXG4gICAgICAgICAgcmVsYXRpb25UbzogY29sbGVjdGlvbkNvbmZpZy5zbHVnLFxuICAgICAgICAgIHR5cGU6ICdyZWxhdGlvbnNoaXAnLFxuICAgICAgICAgIHZhbHVlOiB7IGlkOiBkb2NJRCB9LFxuICAgICAgICB9LFxuICAgICAgICB7IGF0OiBlbGVtZW50UGF0aCB9LFxuICAgICAgKVxuXG4gICAgICBzZXRSZWxhdGVkQ29sbGVjdGlvbihjb2xsZWN0aW9ucy5maW5kKChjb2xsKSA9PiBjb2xsLnNsdWcgPT09IGNvbGxlY3Rpb25Db25maWcuc2x1ZykpXG5cbiAgICAgIHNldFBhcmFtcyh7XG4gICAgICAgIC4uLmluaXRpYWxQYXJhbXMsXG4gICAgICAgIGNhY2hlQnVzdCwgLy8gZG8gdGhpcyB0byBnZXQgdGhlIHVzZVBheWxvYWRBUEkgdG8gcmUtZmV0Y2ggdGhlIGRhdGEgZXZlbiB0aG91Z2ggdGhlIFVSTCBzdHJpbmcgaGFzbid0IGNoYW5nZWRcbiAgICAgIH0pXG5cbiAgICAgIGNsb3NlTGlzdERyYXdlcigpXG4gICAgICBkaXNwYXRjaENhY2hlQnVzdCgpXG4gICAgfSxcbiAgICBbY2xvc2VMaXN0RHJhd2VyLCBlZGl0b3IsIGVsZW1lbnQsIGNhY2hlQnVzdCwgc2V0UGFyYW1zLCBjb2xsZWN0aW9uc10sXG4gIClcblxuICByZXR1cm4gKFxuICAgIDxkaXZcbiAgICAgIGNsYXNzTmFtZT17W2Jhc2VDbGFzcywgc2VsZWN0ZWQgJiYgZm9jdXNlZCAmJiBgJHtiYXNlQ2xhc3N9LS1zZWxlY3RlZGBdXG4gICAgICAgIC5maWx0ZXIoQm9vbGVhbilcbiAgICAgICAgLmpvaW4oJyAnKX1cbiAgICAgIGNvbnRlbnRFZGl0YWJsZT17ZmFsc2V9XG4gICAgICB7Li4uYXR0cmlidXRlc31cbiAgICA+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT17YCR7YmFzZUNsYXNzfV9fd3JhcGB9PlxuICAgICAgICA8cCBjbGFzc05hbWU9e2Ake2Jhc2VDbGFzc31fX2xhYmVsYH0+XG4gICAgICAgICAge3QoJ2xhYmVsUmVsYXRpb25zaGlwJywge1xuICAgICAgICAgICAgbGFiZWw6IGdldFRyYW5zbGF0aW9uKHJlbGF0ZWRDb2xsZWN0aW9uLmxhYmVscy5zaW5ndWxhciwgaTE4biksXG4gICAgICAgICAgfSl9XG4gICAgICAgIDwvcD5cbiAgICAgICAgPERvY3VtZW50RHJhd2VyVG9nZ2xlciBjbGFzc05hbWU9e2Ake2Jhc2VDbGFzc31fX2RvYy1kcmF3ZXItdG9nZ2xlcmB9PlxuICAgICAgICAgIDxwIGNsYXNzTmFtZT17YCR7YmFzZUNsYXNzfV9fdGl0bGVgfT5cbiAgICAgICAgICAgIHtkYXRhW3JlbGF0ZWRDb2xsZWN0aW9uPy5hZG1pbj8udXNlQXNUaXRsZSB8fCAnaWQnXX1cbiAgICAgICAgICA8L3A+XG4gICAgICAgIDwvRG9jdW1lbnREcmF3ZXJUb2dnbGVyPlxuICAgICAgPC9kaXY+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT17YCR7YmFzZUNsYXNzfV9fYWN0aW9uc2B9PlxuICAgICAgICA8TGlzdERyYXdlclRvZ2dsZXJcbiAgICAgICAgICBjbGFzc05hbWU9e2Ake2Jhc2VDbGFzc31fX2xpc3QtZHJhd2VyLXRvZ2dsZXJgfVxuICAgICAgICAgIGRpc2FibGVkPXtmaWVsZFByb3BzPy5hZG1pbj8ucmVhZE9ubHl9XG4gICAgICAgID5cbiAgICAgICAgICA8QnV0dG9uXG4gICAgICAgICAgICBidXR0b25TdHlsZT1cImljb24tbGFiZWxcIlxuICAgICAgICAgICAgZGlzYWJsZWQ9e2ZpZWxkUHJvcHM/LmFkbWluPy5yZWFkT25seX1cbiAgICAgICAgICAgIGVsPVwiZGl2XCJcbiAgICAgICAgICAgIGljb249XCJzd2FwXCJcbiAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHtcbiAgICAgICAgICAgICAgLy8gZG8gbm90aGluZ1xuICAgICAgICAgICAgfX1cbiAgICAgICAgICAgIHJvdW5kXG4gICAgICAgICAgICB0b29sdGlwPXt0KCdzd2FwUmVsYXRpb25zaGlwJyl9XG4gICAgICAgICAgLz5cbiAgICAgICAgPC9MaXN0RHJhd2VyVG9nZ2xlcj5cbiAgICAgICAgPEJ1dHRvblxuICAgICAgICAgIGJ1dHRvblN0eWxlPVwiaWNvbi1sYWJlbFwiXG4gICAgICAgICAgY2xhc3NOYW1lPXtgJHtiYXNlQ2xhc3N9X19yZW1vdmVCdXR0b25gfVxuICAgICAgICAgIGRpc2FibGVkPXtmaWVsZFByb3BzPy5hZG1pbj8ucmVhZE9ubHl9XG4gICAgICAgICAgaWNvbj1cInhcIlxuICAgICAgICAgIG9uQ2xpY2s9eyhlKSA9PiB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgICAgIHJlbW92ZVJlbGF0aW9uc2hpcCgpXG4gICAgICAgICAgfX1cbiAgICAgICAgICByb3VuZFxuICAgICAgICAgIHRvb2x0aXA9e3QoJ2ZpZWxkczpyZW1vdmVSZWxhdGlvbnNoaXAnKX1cbiAgICAgICAgLz5cbiAgICAgIDwvZGl2PlxuICAgICAge3ZhbHVlPy5pZCAmJiA8RG9jdW1lbnREcmF3ZXIgb25TYXZlPXt1cGRhdGVSZWxhdGlvbnNoaXB9IC8+fVxuICAgICAgPExpc3REcmF3ZXIgb25TZWxlY3Q9e3N3YXBSZWxhdGlvbnNoaXB9IC8+XG4gICAgICB7Y2hpbGRyZW59XG4gICAgPC9kaXY+XG4gIClcbn1cblxuZXhwb3J0IGRlZmF1bHQgKHByb3BzOiBQcm9wcyk6IFJlYWN0LlJlYWN0Tm9kZSA9PiB7XG4gIHJldHVybiAoXG4gICAgPEVuYWJsZWRSZWxhdGlvbnNoaXBzQ29uZGl0aW9uIHsuLi5wcm9wc30+XG4gICAgICA8RWxlbWVudCB7Li4ucHJvcHN9IC8+XG4gICAgPC9FbmFibGVkUmVsYXRpb25zaGlwc0NvbmRpdGlvbj5cbiAgKVxufVxuIl0sIm5hbWVzIjpbImJhc2VDbGFzcyIsImluaXRpYWxQYXJhbXMiLCJkZXB0aCIsIkVsZW1lbnQiLCJwcm9wcyIsImF0dHJpYnV0ZXMiLCJjaGlsZHJlbiIsImVsZW1lbnQiLCJyZWxhdGlvblRvIiwidmFsdWUiLCJmaWVsZFByb3BzIiwiY29sbGVjdGlvbnMiLCJyb3V0ZXMiLCJhcGkiLCJzZXJ2ZXJVUkwiLCJ1c2VDb25maWciLCJlbmFibGVkQ29sbGVjdGlvblNsdWdzIiwidXNlU3RhdGUiLCJmaWx0ZXIiLCJhZG1pbiIsImVuYWJsZVJpY2hUZXh0UmVsYXRpb25zaGlwIiwibWFwIiwic2x1ZyIsInJlbGF0ZWRDb2xsZWN0aW9uIiwic2V0UmVsYXRlZENvbGxlY3Rpb24iLCJmaW5kIiwiY29sbCIsInNlbGVjdGVkIiwidXNlU2VsZWN0ZWQiLCJmb2N1c2VkIiwidXNlRm9jdXNlZCIsImkxOG4iLCJ0IiwidXNlVHJhbnNsYXRpb24iLCJlZGl0b3IiLCJ1c2VTbGF0ZVN0YXRpYyIsImNhY2hlQnVzdCIsImRpc3BhdGNoQ2FjaGVCdXN0IiwidXNlUmVkdWNlciIsInN0YXRlIiwiZGF0YSIsInNldFBhcmFtcyIsInVzZVBheWxvYWRBUEkiLCJpZCIsIkRvY3VtZW50RHJhd2VyIiwiRG9jdW1lbnREcmF3ZXJUb2dnbGVyIiwiY2xvc2VEcmF3ZXIiLCJ1c2VEb2N1bWVudERyYXdlciIsImNvbGxlY3Rpb25TbHVnIiwiTGlzdERyYXdlciIsIkxpc3REcmF3ZXJUb2dnbGVyIiwiY2xvc2VMaXN0RHJhd2VyIiwidXNlTGlzdERyYXdlciIsImNvbGxlY3Rpb25TbHVncyIsInNlbGVjdGVkQ29sbGVjdGlvbiIsInJlbW92ZVJlbGF0aW9uc2hpcCIsInVzZUNhbGxiYWNrIiwiZWxlbWVudFBhdGgiLCJSZWFjdEVkaXRvciIsImZpbmRQYXRoIiwiVHJhbnNmb3JtcyIsInJlbW92ZU5vZGVzIiwiYXQiLCJ1cGRhdGVSZWxhdGlvbnNoaXAiLCJSZWFjdCIsImRvYyIsInNldE5vZGVzIiwidGV4dCIsInR5cGUiLCJzd2FwUmVsYXRpb25zaGlwIiwiY29sbGVjdGlvbkNvbmZpZyIsImRvY0lEIiwiZGl2IiwiY2xhc3NOYW1lIiwiQm9vbGVhbiIsImpvaW4iLCJjb250ZW50RWRpdGFibGUiLCJwIiwibGFiZWwiLCJnZXRUcmFuc2xhdGlvbiIsImxhYmVscyIsInNpbmd1bGFyIiwidXNlQXNUaXRsZSIsImRpc2FibGVkIiwicmVhZE9ubHkiLCJCdXR0b24iLCJidXR0b25TdHlsZSIsImVsIiwiaWNvbiIsIm9uQ2xpY2siLCJyb3VuZCIsInRvb2x0aXAiLCJlIiwicHJldmVudERlZmF1bHQiLCJvblNhdmUiLCJvblNlbGVjdCIsIkVuYWJsZWRSZWxhdGlvbnNoaXBzQ29uZGl0aW9uIl0sIm1hcHBpbmdzIjoiOzs7OytCQTRMQTs7O2VBQUE7Ozs0QkExTHVCOzBCQUMwQjt1QkFDbkI7MkJBQ0o7NEJBQ0s7K0RBQzBCOzhCQUMxQjt1QkFDSjs0QkFDMEM7K0NBSXZCO1FBQ3ZDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRVAsTUFBTUEsWUFBWTtBQUVsQixNQUFNQyxnQkFBZ0I7SUFDcEJDLE9BQU87QUFDVDtBQVFBLE1BQU1DLFVBQTJCLENBQUNDO0lBQ2hDLE1BQU0sRUFDSkMsVUFBVSxFQUNWQyxRQUFRLEVBQ1JDLE9BQU8sRUFDUEEsU0FBUyxFQUFFQyxVQUFVLEVBQUVDLEtBQUssRUFBRSxFQUM5QkMsVUFBVSxFQUNYLEdBQUdOO0lBRUosTUFBTSxFQUNKTyxXQUFXLEVBQ1hDLFFBQVEsRUFBRUMsR0FBRyxFQUFFLEVBQ2ZDLFNBQVMsRUFDVixHQUFHQyxJQUFBQSxvQkFBUztJQUNiLE1BQU0sQ0FBQ0MsdUJBQXVCLEdBQUdDLElBQUFBLGVBQVEsRUFBQyxJQUN4Q04sWUFDR08sTUFBTSxDQUFDLENBQUMsRUFBRUMsT0FBTyxFQUFFQywwQkFBMEIsRUFBRSxFQUFFLEdBQUtBLDRCQUN0REMsR0FBRyxDQUFDLENBQUMsRUFBRUMsSUFBSSxFQUFFLEdBQUtBO0lBRXZCLE1BQU0sQ0FBQ0MsbUJBQW1CQyxxQkFBcUIsR0FBR1AsSUFBQUEsZUFBUSxFQUFDLElBQ3pETixZQUFZYyxJQUFJLENBQUMsQ0FBQ0MsT0FBU0EsS0FBS0osSUFBSSxLQUFLZDtJQUUzQyxNQUFNbUIsV0FBV0MsSUFBQUEsdUJBQVc7SUFDNUIsTUFBTUMsVUFBVUMsSUFBQUEsc0JBQVU7SUFDMUIsTUFBTSxFQUFFQyxJQUFJ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